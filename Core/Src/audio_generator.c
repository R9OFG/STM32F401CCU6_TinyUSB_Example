/*
 * audio_generator.c
 *
 * Author: R9OFG.RU
 * https://r9ofg.ru
 *
 * Генератор тестового аудиосигнала для UAC1 (микрофонная эмуляция SDR)
 * Режим ON:  комплексный тон 1 кГц (I=cos, Q=sin) на уровне S9+20 (-53 dBFS) + шум ±1
 * Режим OFF: только шумовая полка (-96 dBFS, ±1) — имитация "пустого эфира" без цифрового нуля
 *
 * Расчёт амплитуды:
 *   0 dBFS = 32767 (полная шкала 16 бит)
 *   -53 dBFS = 32767 * 10^(-53/20) = 32767 * 0.00224 = 73.4 → округлено до 73
 *   Уровень шума: +/-1 = -90.3 dBFS (пиковый), после усреднения в спектре ≈ -120 дБ
 */

#include "audio_generator.h"
#include <string.h>

static audio_gen_state_t gen_state = AUDIO_GEN_STATE_OFF;  // Состояние генератора (по умолчанию выключен)
static uint8_t phase = 0;  // Фазовый счётчик: позиция в периоде сигнала (0..47), обеспечивает бесшовную петлю

// Таблица комплексного тона 1 кГц на уровне S9+20 (-53 dBFS)
// Амплитуда = 73, 48 отсчётов на период (48000 Гц / 1000 Гц = 48)
// Формат: [I0, Q0, I1, Q1, ..., I47, Q47] — 96 значений для 48 стерео-фреймов
// Значения рассчитаны как: I = 73 * cos(2π*n/48), Q = 73 * sin(2π*n/48), округлено до целого
static const int8_t iq_s9p20_base[96] = {
  73,  0, 72, 10, 70, 19, 67, 28, 63, 36, 58, 44, 52, 52, 44, 58,
  36, 63, 28, 67, 19, 70, 10, 72,  0, 73,-10, 72,-19, 70,-28, 67,
 -36, 63,-44, 58,-52, 52,-58, 44,-63, 36,-67, 28,-70, 19,-72, 10,
 -73,  0,-72,-10,-70,-19,-67,-28,-63,-36,-58,-44,-52,-52,-44,-58,
 -36,-63,-28,-67,-19,-70,-10,-72,  0,-73, 10,-72, 19,-70, 28,-67,
  36,-63, 44,-58, 52,-52, 58,-44, 63,-36, 67,-28, 70,-19, 72,-10
};

// LFSR (Linear Feedback Shift Register) для генерации псевдослучайного шума +/-1
// Полином: x^16 + x^14 + x^13 + x^11 + 1 (0xB400)
// Период повторения: 65535 отсчётов — достаточно для аудио без заметной корреляции
static uint32_t lfsr = 0xACE1u;

// Генерация одного отсчёта шума: +/-1 с равной вероятностью
static inline int8_t get_noise_sample(void)
{
  lfsr = (lfsr >> 1) ^ (-(lfsr & 1u) & 0xB400u);  // Сдвиг + обратная связь при выходе '1'
  return (lfsr & 1) ? 1 : -1;  // Младший бит определяет знак
}

// Инициализация генератора (вызывается один раз при старте)
void audio_generator_init(void)
{
  gen_state = AUDIO_GEN_STATE_OFF;
  phase = 0;
  lfsr = 0xACE1u;  // Начальное значение для воспроизводимости
}

// Установка состояния генератора (вызывается из CDC-команды)
void audio_generator_set_state(audio_gen_state_t state)
{
  gen_state = state;

  if (state == AUDIO_GEN_STATE_OFF)
  {
    phase = 0;  // Сброс фазы при выключении — при следующем включении начнём с начала периода
  }
  // При включении (ON) фаза НЕ сбрасывается — обеспечивает плавный переход без щелчка
}

// Чтение текущего состояния генератора
audio_gen_state_t audio_generator_get_state(void)
{
  return gen_state;
}

// Заполнение буфера аудиоданными для изохронной передачи
// buffer: указатель на буфер 16-битных отсчётов (формат little-endian)
// n_frames: количество стерео-фреймов (обычно 48 = 1 мс при 48 кГц)
void audio_generator_fill_buffer(int16_t *buffer, uint32_t n_frames)
{
  // Защита от некорректного размера (должно быть 48 фреймов для 1 мс)
  if (n_frames != 48)
  {
    memset(buffer, 0, n_frames * 2 * sizeof(int16_t));
    return;
  }

  if (gen_state == AUDIO_GEN_STATE_ON)
  {
    // Режим генерации: комплексный тон + шум
    for (uint32_t i = 0; i < n_frames * 2; i++)
    {
      // Расчёт индекса с учётом текущей фазы (бесшовная петля через модуль 48)
      uint8_t idx = ((phase + i / 2) % 48) * 2 + (i % 2);
      int16_t sample = iq_s9p20_base[idx];

      // Добавление шума +/-1 к КАЖДОМУ отсчёту (формирует шумовую полку)
      sample += get_noise_sample();

      // Ограничение амплитуды: 73 + 1 = 74 (защита от переполнения)
      if (sample > 74) sample = 74;
      else if (sample < -74) sample = -74;

      buffer[i] = sample;
    }

    // Обновление фазы с заворотом на границе периода (48 фреймов = 1 период 1 кГц)
    phase = (phase + n_frames) % 48;
  }
  else
  {
    // Режим ожидания: только шумовая полка (-96 dBFS)
    // Имитирует фоновый шум реального приёмника при отсутствии сигнала
    for (uint32_t i = 0; i < n_frames * 2; i++)
    {
      buffer[i] = get_noise_sample();  // +/-1 ко всем отсчётам (левый и правый каналы)
    }
  }
}
